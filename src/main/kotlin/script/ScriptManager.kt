package script

import client.MapleClient
import network.packet.ScriptMan
import org.slf4j.LoggerFactory
import script.template.*
import server.MapleItemInformationProvider
import server.life.MapleNPC
import server.quest.MapleQuest
import tools.data.input.SeekableLittleEndianAccessor
import java.io.File
import java.io.FileNotFoundException
import java.io.FileReader
import java.util.*
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.locks.Lock
import java.util.concurrent.locks.ReentrantLock
import javax.script.*
import kotlin.experimental.and


class ScriptManager {

    companion object {

        //Decoder Status
        const val Ready = 0
        const val Decoding = 1
        const val Message = 2
        const val Pending = 3
        const val Finishing = 4
        private val pool = Executors.newCachedThreadPool()
        private val logger = LoggerFactory.getLogger(ScriptManager::class.java)
        private var oid: Int
        var posScriptHistory: Int
        var scriptHist: ArrayList<ScriptHistory>
        var status: AtomicInteger
        private val continuation: Object
        var lock: Lock
        var value: Any? = null
        private var inputNo = 0
        private var inputStr: String? = null

        init {
            oid = 0
            posScriptHistory = 0
            scriptHist = ArrayList<ScriptHistory>()
            status = AtomicInteger(Ready)
            continuation = Object()
            lock = ReentrantLock()
        }

        /**
         * responsible for running all scripts in the game
         *
         * @param client of the user
         * @param objectId either the field objectId or questId
         * @param name the name of the script (this is pulled from the wz files)
         * @param scriptType see ScriptType.kt for enum values
         */
        @JvmStatic
        fun runScript(client: MapleClient, objectId: Int, name: String, scriptType: ScriptType) {
            val scriptFile = File("./scripts/${scriptType.type}/$name.groovy")
            oid = objectId
            if (!scriptFile.exists()) {
                // if the file doesn't exist we generate one
                handleMissingScript(client, objectId, name, scriptType)
                return
            }

            val scriptFunc = ScriptFunc(this, objectId, client.player) // so that we can access the companion obj
            val bindings = SimpleBindings().apply {
                // add our bindings to use when scripting
                put("user", client.player)
                put("field", client.player.map)
                put("script", scriptFunc)
            }

            pool.execute {
                try {
                    val engine = ScriptEngineManager().getEngineByExtension("groovy")!!
                    engine.eval(FileReader(scriptFile), bindings)
                } catch (se: ScriptException) {
                    logger.error("Error running script: ${se.message}", se)
                } catch (fnfe: FileNotFoundException) {
                    logger.error("Error the file was not found: ${fnfe.message}", fnfe)
                } finally {
                    destroy()
                }
            }
        }

        private fun handleMissingScript(client: MapleClient, objectId: Int, name: String, type: ScriptType) {
            val autoGenScript: Any?
            when (type) {
                ScriptType.None -> {}
                ScriptType.Npc -> {
                    autoGenScript = AutoGeneratedNpcScriptTemplate(
                        client.player.map.getMapObject(objectId) as MapleNPC,
                        client,
                        name
                    )
                    autoGenScript.create()
                }

                ScriptType.UserEnterField -> { // onUserEnter
                    autoGenScript = AutoGeneratedFieldScriptTemplate(
                        client.player.map,
                        name,
                        false
                    )
                    autoGenScript.create()
                }

                ScriptType.FirstEnterField -> {
                    autoGenScript = AutoGeneratedFieldScriptTemplate(
                        client.player.map,
                        name,
                        true
                    )
                    autoGenScript.create()
                }

                ScriptType.Portal -> {
                    autoGenScript = AutoGeneratedPortalScriptTemplate(
                        client.player.map.getPortal(objectId),
                        client
                    )
                    autoGenScript.create()
                }

                ScriptType.Reactor -> {
                    autoGenScript = AutoGeneratedReactorScriptTemplate(
                        client.player.map.getReactorById(objectId),
                        client
                    )
                    autoGenScript.create()
                }

                ScriptType.Item -> {
                    val ii = MapleItemInformationProvider.getInstance()
                    val info = ii.getScriptedItemInfo(objectId) // item id in this case
                    autoGenScript = AutoGeneratedItemScriptTemplate(info, client)
                    autoGenScript.create()
                }

                ScriptType.Quest -> {
                    autoGenScript = AutoGeneratedQuestScriptTemplate(
                        client.player.getQuest(MapleQuest.getInstance(objectId)),
                        client,
                        name
                    )
                    autoGenScript.create()
                }
            }
            if (type == ScriptType.UserEnterField || type == ScriptType.FirstEnterField) {
                // treating field differently to prevent DC
                client.player.message("The following map object does not have a script. Therefore, a temporary script will now be generated.")
            } else {
                client.announce(
                    ScriptMan.onSay(
                        9010000, // maple admin npc
                        "The following map object does not have a script. Therefore, a temporary script will now be generated.",
                        back = false,
                        next = false
                    )
                )
            }
        }

        /**
         * By using the actual quest name when naming our groovy scripts,
         * we get a lot of spaces and punctuation. This method returns a
         * camelcase version of the original name.
         *
         * @param script the name of the quest extracted from the wz file
         */
        fun sanitizeScriptName(script: String): String {
            val camel = script.replaceFirstChar { it.lowercase() }
            return camel.filter { it.isLetterOrDigit() }
        }

        /*
        below is the handling of the ScriptMessageAnswer packet and all it's components. I'm putting
        it here temporarily because I need access to this companion object.
         */
        @JvmStatic
        fun onScriptMessageAnswer(slea: SeekableLittleEndianAccessor, client: MapleClient) {
            if (posScriptHistory == 0 || scriptHist.isEmpty()) {
                return
            }
            val msgType: Byte = slea.readByte()
            var action: Byte = slea.readByte()

            when (msgType) {
                ScriptMessageType.Say.type.toByte() -> {
                    var posMsgHistory: Int
                    if (action > 0) {
                        if (action.toInt() != 1) {
                            tryFinish()
                            return
                        }
                        if (posScriptHistory == scriptHist.size) {
                            tryResume()
                            return
                        }
                        posMsgHistory = posScriptHistory + 1
                    } else {
                        if (action < 0 || posScriptHistory == 0) {
                            tryFinish()
                            return
                        }
                        posMsgHistory = posScriptHistory - 1
                    }
                    posScriptHistory = posMsgHistory
                    var hist: ScriptHistory = scriptHist[posMsgHistory - 1]
                    var next: Boolean = hist.memory?.get(1).toString().isEmpty()
                    client.announce(
                        ScriptMan.onSay(
                            (client.player.map.getMapObject(oid) as MapleNPC).id,
                            hist.memory?.get(0).toString(),
                            posMsgHistory != 1,
                            next
                        )
                    )
                }

                ScriptMessageType.AskYesNo.type.toByte() -> {
                    if (action.toInt() == -1) {
                        tryFinish()
                        return
                    }
                    this.value = action
                    tryResume()
                }

                ScriptMessageType.AskAvatar.type.toByte() -> {
                    if (action.toInt() == 0) {
                        tryFinish()
                        return
                    }
                    val selection = slea.readByte()
                    if ((selection and 0x80.toByte()).toInt() == 0) {
                        var hist: ScriptHistory = scriptHist[posScriptHistory - 1]
                        if (hist != null && hist.memory?.size!! > 2) {
                            var candidate = hist.memory!![2] as IntArray
                            // change the styles here
                        } else {
                            action = selection
                        }
                    }
                    this.value = action
                    tryResume()
                }
                ScriptMessageType.AskMenu.type.toByte() -> {
                    if (action.toInt() == 0) {
                        tryFinish()
                        return
                    }
                    this.value = slea.readInt()
                    tryResume()
                }

                ScriptMessageType.AskText.type.toByte() -> {
                    if (action.toInt() == 0) {
                        tryFinish()
                        return
                    }
                    this.inputStr = slea.readMapleAsciiString()
                    this.value = this.inputStr
                    tryResume()
                }

                ScriptMessageType.AskNumber.type.toByte() -> {
                    if (action.toInt() == 0) {
                        tryFinish()
                        return
                    }
                    this.inputNo = slea.readInt()
                    this.value = this.inputNo
                    tryResume()
                }

                else -> {
                    tryFinish()
                }
                // other msgType cases go here
            }
        }

        fun destroy() {
            lock.lock()
            try {
                if (status.get() != Ready) {
                    status.set(Ready)
                }
                scriptHist.clear()
                posScriptHistory = 0
            } finally {
                lock.unlock()
            }
        }

        private fun tryFinish() {
            if (status.get() != Finishing) {
                if (status.get() != Pending) {
                    status.set(Pending)
                    clearHistory()
                    clear()
                    tryResume()
                } else {
                    clear()
                }
            }
        }

        fun tryCapture() {
            this.value = null
            synchronized(continuation) {
                try {
                    continuation.wait()
                } catch (ex: InterruptedException) {
                    continuation.notifyAll()
                }
            }
        }

        private fun tryResume() {
            if (status.get() != Finishing) {
                synchronized(continuation) {
                    continuation.notifyAll()
                }
            }
        }

        private fun clearHistory() {
            scriptHist.clear()
            posScriptHistory = 0
        }

        fun clear() {
            if (status.get() != Finishing) {
                status.set(Finishing)
                destroy()
            }
        }

        // end of ScriptMessageAnswer handling
    }
}